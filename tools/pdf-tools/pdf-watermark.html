<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="pdfWatermark.title">PDF 워터마크 추가기 - 무료 온라인 도구</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="PDF 파일에 워터마크를 추가하세요. 텍스트 또는 이미지 워터마크를 지원하며 브라우저에서 안전하게 처리됩니다." data-i18n-content="pdfWatermark.description">
    <meta name="keywords" content="PDF 워터마크, PDF 텍스트 추가, PDF 이미지 추가, 온라인 PDF 편집" data-i18n-content="pdfWatermark.keywords">
    
    <!-- Open Graph -->
    <meta property="og:title" content="PDF 워터마크 추가기 - 무료 온라인 도구">
    <meta property="og:description" content="PDF 파일에 워터마크를 추가하세요. 브라우저에서 안전하게 처리되어 개인정보 보호가 보장됩니다.">
    <meta property="og:type" content="website">
    
    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9434360911371069"
     crossorigin="anonymous"></script>
    
    <!-- Cookie Consent Management -->
    <script src="../../cookie-consent.js"></script>
    
    <!-- Feedback System -->
    <script src="../../feedback.js"></script>
    
    <!-- i18n System -->
    <script src="../../i18n.js"></script>
    
    <!-- PDF-lib Library -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .nav-bar {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .nav-brand {
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-decoration: none;
            white-space: nowrap;
        }
        
        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        
        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            padding: 10px 16px;
            border-radius: 5px;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
        }
        
        .nav-link:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .nav-link.active {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .menu-toggle {
            display: none;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: white;
            padding: 5px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }
        
        .menu-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        @media (max-width: 768px) {
            .nav-bar {
                padding: 12px 15px;
                min-height: 50px;
                position: relative;
            }
            
            .nav-brand {
                font-size: 1.3em;
            }
            
            .menu-toggle {
                display: block;
            }
            
            .nav-links {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: rgba(0, 0, 0, 0.9);
                backdrop-filter: blur(10px);
                border-radius: 0 0 10px 10px;
                box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                flex-direction: column;
                gap: 0;
                padding: 15px 0;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-top: none;
            }
            
            .nav-links.active {
                display: flex;
            }
            
            .nav-link {
                padding: 12px 20px;
                font-size: 16px;
                border-radius: 0;
                display: block;
                width: 100%;
                text-align: left;
                transition: background-color 0.3s ease;
            }
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .upload-section {
            margin-bottom: 30px;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover {
            background: linear-gradient(135deg, #e8f0ff 0%, #d8e8ff 100%);
            transform: translateY(-2px);
        }
        
        .upload-area.dragover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: white;
        }
        
        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .upload-area.dragover .upload-icon {
            color: white;
        }
        
        .upload-text {
            font-size: 1.3em;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .upload-subtext {
            color: #666;
            font-size: 1em;
        }
        
        .upload-area.dragover .upload-subtext {
            color: rgba(255, 255, 255, 0.8);
        }
        
        #fileInput {
            display: none;
        }
        
        .file-info {
            display: none;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #667eea;
        }
        
        .file-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .file-size {
            color: #666;
            font-size: 0.9em;
        }
        
        .watermark-options {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .watermark-type {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .type-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .type-option input[type="radio"] {
            margin: 0;
        }
        
        .option-group {
            margin-bottom: 20px;
        }
        
        .option-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }
        
        .option-group input,
        .option-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .option-group input[type="range"] {
            width: 100%;
        }
        
        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #667eea;
        }
        
        .text-watermark-options,
        .image-watermark-options {
            display: none;
        }
        
        .text-watermark-options.active,
        .image-watermark-options.active {
            display: block;
        }
        
        .position-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .position-btn {
            padding: 15px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .position-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .position-btn.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .process-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: block;
            margin: 30px auto;
            min-width: 200px;
        }
        
        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        .process-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .progress-section {
            display: none;
            text-align: center;
            margin: 30px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .progress-text {
            font-size: 1.1em;
            color: #333;
            margin-bottom: 10px;
        }
        
        .download-section {
            display: none;
            text-align: center;
            margin: 30px 0;
            padding: 25px;
            background: #e8f5e8;
            border-radius: 10px;
            border: 1px solid #4caf50;
        }
        
        .download-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin: 10px;
        }
        
        .download-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }
        
        .features-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 40px 0;
        }
        
        .feature-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        
        .feature-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
            color: #667eea;
        }
        
        .feature-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        .feature-description {
            color: #666;
            line-height: 1.5;
        }
        
        .error-message {
            display: none;
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #ef5350;
        }
        
        .language-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .language-switcher select {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: #333;
            padding: 8px 12px;
            font-size: 14px;
            width: 90px;
        }
        
        @media (max-width: 768px) {
            .main-layout {
                padding: 15px;
            }
            
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .upload-area {
                padding: 40px 15px;
            }
            
            .features-section {
                grid-template-columns: 1fr;
            }
            
            .language-switcher {
                top: 15px;
                right: 15px;
            }
            
            .watermark-type {
                flex-direction: column;
                gap: 10px;
            }
            
            .position-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* 미리보기 스타일 */
        .preview-section {
            background: #f0f4f8;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 1px solid #e1e8ed;
        }
        
        .preview-section h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.1em;
        }
        
        .preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            background: #fff;
            border-radius: 8px;
            border: 2px solid #ddd;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .preview-page {
            width: 280px;
            height: 180px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .preview-content {
            width: 100%;
            height: 100%;
            position: relative;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .preview-text {
            color: #999;
            font-size: 12px;
            line-height: 1.6;
            margin-bottom: 10px;
            opacity: 0.7;
        }
        
        .preview-watermark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .preview-watermark span {
            /* 모든 스타일은 JavaScript에서 동적으로 설정 */
        }
        
        .preview-watermark img {
            /* 모든 스타일은 JavaScript에서 동적으로 설정 */
        }
        
        @media (max-width: 768px) {
            .preview-page {
                width: 240px;
                height: 150px;
            }
            
            .preview-watermark span {
                font-size: 24px;
            }
            
            .preview-watermark img {
                max-width: 60px;
                max-height: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="language-switcher">
        <select id="languageSelect">
            <option value="ko" data-i18n="common.languageKo">🇰🇷 KO</option>
            <option value="en" data-i18n="common.languageEn">🇺🇸 EN</option>
        </select>
    </div>

    <div class="nav-bar">
        <a href="../../index.html" class="nav-brand" data-i18n="common.siteTitle">🛠️ 웹 도구 모음</a>
        <button class="menu-toggle" onclick="toggleMenu()">☰</button>
        <div class="nav-links" id="navLinks">
            <a href="../password-generator/password.html" class="nav-link" data-i18n="common.passwordGenerator">비밀번호 생성기</a>
            <a href="png-converter.html" class="nav-link" data-i18n="common.pdfConverter">PDF 변환기</a>
            <a href="hwp-converter.html" class="nav-link">PDF to HWP</a>
            <a href="epub-to-pdf.html" class="nav-link">ePub to PDF</a>
            <a href="pdf-watermark.html" class="nav-link active">PDF 워터마크</a>
            <a href="../image-tools/webp-to-jpg.html" class="nav-link">WEBP to JPG</a>
            <a href="../file-conversion/file-conversion.html" class="nav-link" data-i18n="common.fileConverter">파일 변환 가이드</a>
        </div>
    </div>
    
    <div class="main-layout">
        <div class="container">
            <h1 data-i18n="pdfWatermark.mainTitle">📄 PDF 워터마크 추가기</h1>
            
            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">📄</div>
                    <div class="upload-text" data-i18n="pdfWatermark.uploadText">PDF 파일을 선택하거나 드래그하세요</div>
                    <div class="upload-subtext" data-i18n="pdfWatermark.uploadSubtext">지원 형식: .pdf (최대 50MB)</div>
                    <input type="file" id="fileInput" accept=".pdf" />
                </div>
                
                <div class="file-info" id="fileInfo">
                    <div class="file-name" id="fileName"></div>
                    <div class="file-size" id="fileSize"></div>
                </div>
            </div>
            
            <div class="error-message" id="errorMessage"></div>
            
            <div class="watermark-options">
                <h3 data-i18n="pdfWatermark.watermarkOptions">워터마크 옵션</h3>
                
                <!-- 미리보기 섹션 -->
                <div class="preview-section">
                    <h4 data-i18n="pdfWatermark.preview">미리보기</h4>
                    <div class="preview-container">
                        <div class="preview-page" id="previewPage">
                            <div class="preview-content">
                                <div class="preview-text">Sample PDF Document</div>
                                <div class="preview-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</div>
                                <div class="preview-text">Sed do eiusmod tempor incididunt ut labore et dolore magna.</div>
                                <div class="preview-text">Ut enim ad minim veniam, quis nostrud exercitation.</div>
                                <div class="preview-watermark" id="previewWatermark">
                                    <span id="previewText">WATERMARK</span>
                                    <img id="previewImage" style="display: none;" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="watermark-type">
                    <div class="type-option">
                        <input type="radio" name="watermarkType" id="textWatermark" value="text" checked>
                        <label for="textWatermark" data-i18n="pdfWatermark.textWatermark">텍스트 워터마크</label>
                    </div>
                    <div class="type-option">
                        <input type="radio" name="watermarkType" id="imageWatermark" value="image">
                        <label for="imageWatermark" data-i18n="pdfWatermark.imageWatermark">이미지 워터마크</label>
                    </div>
                </div>
                
                <div class="text-watermark-options active" id="textOptions">
                    <div class="option-group">
                        <label for="watermarkText" data-i18n="pdfWatermark.watermarkText">워터마크 텍스트:</label>
                        <input type="text" id="watermarkText" placeholder="워터마크 텍스트를 입력하세요" data-i18n-placeholder="pdfWatermark.textPlaceholder">
                        <small style="color: #666; font-size: 0.9em; margin-top: 5px; display: block;" data-i18n="pdfWatermark.textNote">
                            ℹ️ 한글/특수문자는 이미지로 변환되어 처리됩니다
                        </small>
                    </div>
                    
                    <div class="option-group">
                        <label for="textSize" data-i18n="pdfWatermark.textSize">텍스트 크기: <span class="range-value" id="textSizeValue">36px</span></label>
                        <input type="range" id="textSize" min="12" max="72" value="36" />
                    </div>
                    
                    <div class="option-group">
                        <label for="textColor" data-i18n="pdfWatermark.textColor">텍스트 색상:</label>
                        <input type="color" id="textColor" value="#e74c3c" />
                    </div>
                </div>
                
                <div class="image-watermark-options" id="imageOptions">
                    <div class="option-group">
                        <label for="watermarkImage" data-i18n="pdfWatermark.watermarkImage">워터마크 이미지:</label>
                        <input type="file" id="watermarkImage" accept="image/*" />
                    </div>
                    
                    <div class="option-group">
                        <label for="imageSize" data-i18n="pdfWatermark.imageSize">이미지 크기: <span class="range-value" id="imageSizeValue">100px</span></label>
                        <input type="range" id="imageSize" min="50" max="300" value="100" />
                    </div>
                </div>
                
                <div class="option-group">
                    <label for="opacity" data-i18n="pdfWatermark.opacity">투명도: <span class="range-value" id="opacityValue">50%</span></label>
                    <input type="range" id="opacity" min="10" max="100" value="50" />
                </div>
                
                <div class="option-group">
                    <label data-i18n="pdfWatermark.position">위치:</label>
                    <div class="position-grid">
                        <button class="position-btn" data-position="top-left" data-i18n="pdfWatermark.topLeft">왼쪽 상단</button>
                        <button class="position-btn" data-position="top-center" data-i18n="pdfWatermark.topCenter">중앙 상단</button>
                        <button class="position-btn" data-position="top-right" data-i18n="pdfWatermark.topRight">오른쪽 상단</button>
                        <button class="position-btn" data-position="center-left" data-i18n="pdfWatermark.centerLeft">왼쪽 중앙</button>
                        <button class="position-btn active" data-position="center" data-i18n="pdfWatermark.center">중앙</button>
                        <button class="position-btn" data-position="center-right" data-i18n="pdfWatermark.centerRight">오른쪽 중앙</button>
                        <button class="position-btn" data-position="bottom-left" data-i18n="pdfWatermark.bottomLeft">왼쪽 하단</button>
                        <button class="position-btn" data-position="bottom-center" data-i18n="pdfWatermark.bottomCenter">중앙 하단</button>
                        <button class="position-btn" data-position="bottom-right" data-i18n="pdfWatermark.bottomRight">오른쪽 하단</button>
                    </div>
                </div>
            </div>
            
            <button class="process-btn" id="processBtn" disabled data-i18n="pdfWatermark.addWatermark">워터마크 추가하기</button>
            
            <div class="progress-section" id="progressSection">
                <div class="progress-text" id="progressText" data-i18n="pdfWatermark.processing">처리 중...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="download-section" id="downloadSection">
                <h3 data-i18n="pdfWatermark.complete">✅ 완료!</h3>
                <p data-i18n="pdfWatermark.completeDesc">PDF 파일에 워터마크가 성공적으로 추가되었습니다.</p>
                <a href="#" class="download-btn" id="downloadBtn" data-i18n="pdfWatermark.downloadBtn">📥 PDF 다운로드</a>
            </div>
            
            <div class="features-section">
                <div class="feature-card">
                    <div class="feature-icon">🔒</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.privacy.title">개인정보 보호</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.privacy.description">모든 처리는 브라우저에서 직접 수행되어 파일이 서버로 전송되지 않습니다.</div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">⚡</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.fast.title">빠른 처리</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.fast.description">최적화된 알고리즘으로 빠르고 정확한 워터마크 추가를 제공합니다.</div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">🎨</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.customizable.title">다양한 옵션</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.customizable.description">텍스트와 이미지 워터마크, 위치, 크기, 투명도 등을 자유롭게 설정할 수 있습니다.</div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">📱</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.responsive.title">모든 기기 지원</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.responsive.description">PC, 태블릿, 모바일 등 모든 기기에서 사용할 수 있습니다.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PDFWatermarkTool {
            constructor() {
                this.currentFile = null;
                this.selectedPosition = 'center';
                this.initializeElements();
                this.bindEvents();
                this.updateRangeValues();
                this.updatePreview(); // 초기 미리보기 설정
            }
            
            initializeElements() {
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.fileInfo = document.getElementById('fileInfo');
                this.fileName = document.getElementById('fileName');
                this.fileSize = document.getElementById('fileSize');
                this.processBtn = document.getElementById('processBtn');
                this.progressSection = document.getElementById('progressSection');
                this.progressText = document.getElementById('progressText');
                this.progressFill = document.getElementById('progressFill');
                this.downloadSection = document.getElementById('downloadSection');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.errorMessage = document.getElementById('errorMessage');
                
                // Watermark option elements
                this.textWatermark = document.getElementById('textWatermark');
                this.imageWatermark = document.getElementById('imageWatermark');
                this.textOptions = document.getElementById('textOptions');
                this.imageOptions = document.getElementById('imageOptions');
                this.watermarkText = document.getElementById('watermarkText');
                this.textSize = document.getElementById('textSize');
                this.textColor = document.getElementById('textColor');
                this.watermarkImage = document.getElementById('watermarkImage');
                this.imageSize = document.getElementById('imageSize');
                this.opacity = document.getElementById('opacity');
                
                // Position buttons
                this.positionButtons = document.querySelectorAll('.position-btn');
                
                // Preview elements
                this.previewWatermark = document.getElementById('previewWatermark');
                this.previewText = document.getElementById('previewText');
                this.previewImage = document.getElementById('previewImage');
            }
            
            bindEvents() {
                // File input events
                this.uploadArea.addEventListener('click', () => this.fileInput.click());
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Drag and drop events
                this.uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                this.uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                this.uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                
                // Watermark type change
                this.textWatermark.addEventListener('change', () => {
                    this.toggleWatermarkType();
                    this.updatePreview();
                });
                this.imageWatermark.addEventListener('change', () => {
                    this.toggleWatermarkType();
                    this.updatePreview();
                });
                
                // Text input changes
                this.watermarkText.addEventListener('input', () => this.updatePreview());
                this.textColor.addEventListener('input', () => this.updatePreview());
                this.watermarkImage.addEventListener('change', () => this.updatePreview());
                
                // Range inputs
                this.textSize.addEventListener('input', (e) => {
                    console.log('Text size changed:', e.target.value);
                    this.updateRangeValues();
                    this.updatePreview();
                });
                this.imageSize.addEventListener('input', (e) => {
                    console.log('Image size changed:', e.target.value);
                    this.updateRangeValues();
                    this.updatePreview();
                });
                this.opacity.addEventListener('input', (e) => {
                    console.log('Opacity changed:', e.target.value);
                    this.updateRangeValues();
                    this.updatePreview();
                });
                
                // Position buttons
                this.positionButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.selectPosition(btn);
                        this.updatePreview();
                    });
                });
                
                // Process button
                this.processBtn.addEventListener('click', () => this.processWatermark());
            }
            
            updateRangeValues() {
                document.getElementById('textSizeValue').textContent = this.textSize.value + 'px';
                document.getElementById('imageSizeValue').textContent = this.imageSize.value + 'px';
                document.getElementById('opacityValue').textContent = this.opacity.value + '%';
            }
            
            updatePreview() {
                const isTextWatermark = this.textWatermark.checked;
                
                if (isTextWatermark) {
                    this.updateTextPreview();
                } else {
                    this.updateImagePreview();
                }
                
                this.updateWatermarkPosition();
            }
            
            updateTextPreview() {
                const text = this.watermarkText.value || 'WATERMARK';
                const fontSize = parseInt(this.textSize.value);
                const color = this.textColor.value;
                const opacity = parseInt(this.opacity.value) / 100;
                
                // 미리보기용 크기 조정 (실제 크기의 60% 정도로 스케일링)
                const previewFontSize = Math.max(fontSize * 0.6, 12);
                
                console.log('UpdateTextPreview called:', { text, fontSize, previewFontSize, color, opacity });
                
                // 완전히 새로운 span 요소 생성
                const newSpan = document.createElement('span');
                newSpan.id = 'previewText';
                newSpan.textContent = text;
                
                // 직접 스타일 적용 (CSS 우선순위 무시)
                newSpan.setAttribute('style', `
                    font-family: Arial, sans-serif;
                    font-size: ${previewFontSize}px;
                    color: ${color};
                    opacity: ${opacity};
                    white-space: nowrap;
                    text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
                    font-weight: bold;
                    display: block;
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `);
                
                // 기존 요소 제거하고 새 요소 추가
                this.previewText.parentNode.replaceChild(newSpan, this.previewText);
                this.previewText = newSpan;
                
                this.previewImage.style.display = 'none';
                
                console.log('Text preview updated with new element');
            }
            
            updateImagePreview() {
                const imageFile = this.watermarkImage.files[0];
                const imageSize = parseInt(this.imageSize.value);
                const opacity = parseInt(this.opacity.value) / 100;
                
                console.log('UpdateImagePreview called:', { imageFile: !!imageFile, imageSize, opacity });
                
                if (imageFile) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        // 미리보기용 크기 조정 (실제 크기의 50% 정도로 스케일링)
                        const previewSize = Math.max(imageSize * 0.5, 30);
                        
                        console.log('Image preview size:', previewSize);
                        
                        // 완전히 새로운 img 요소 생성
                        const newImg = document.createElement('img');
                        newImg.id = 'previewImage';
                        newImg.src = e.target.result;
                        
                        // 직접 스타일 적용
                        newImg.setAttribute('style', `
                            width: ${previewSize}px;
                            height: ${previewSize}px;
                            opacity: ${opacity};
                            display: block;
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                        `);
                        
                        // 기존 요소 제거하고 새 요소 추가
                        this.previewImage.parentNode.replaceChild(newImg, this.previewImage);
                        this.previewImage = newImg;
                        
                        this.previewText.style.display = 'none';
                        
                        console.log('Image preview updated with new element');
                    };
                    reader.readAsDataURL(imageFile);
                } else {
                    this.previewImage.style.display = 'none';
                    this.previewText.style.display = 'none';
                }
            }
            
            updateWatermarkPosition() {
                const position = this.selectedPosition;
                const container = this.previewWatermark;
                
                // 기본값 초기화
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%) rotate(-45deg)';
                
                // 위치별 조정
                switch (position) {
                    case 'top-left':
                        container.style.top = '25%';
                        container.style.left = '25%';
                        break;
                    case 'top-center':
                        container.style.top = '25%';
                        container.style.left = '50%';
                        break;
                    case 'top-right':
                        container.style.top = '25%';
                        container.style.left = '75%';
                        break;
                    case 'center-left':
                        container.style.top = '50%';
                        container.style.left = '25%';
                        break;
                    case 'center':
                        container.style.top = '50%';
                        container.style.left = '50%';
                        break;
                    case 'center-right':
                        container.style.top = '50%';
                        container.style.left = '75%';
                        break;
                    case 'bottom-left':
                        container.style.top = '75%';
                        container.style.left = '25%';
                        break;
                    case 'bottom-center':
                        container.style.top = '75%';
                        container.style.left = '50%';
                        break;
                    case 'bottom-right':
                        container.style.top = '75%';
                        container.style.left = '75%';
                        break;
                }
            }
            
            toggleWatermarkType() {
                if (this.textWatermark.checked) {
                    this.textOptions.classList.add('active');
                    this.imageOptions.classList.remove('active');
                } else {
                    this.textOptions.classList.remove('active');
                    this.imageOptions.classList.add('active');
                }
            }
            
            selectPosition(btn) {
                this.positionButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.selectedPosition = btn.dataset.position;
            }
            
            handleDragOver(e) {
                e.preventDefault();
                this.uploadArea.classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                this.uploadArea.classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                this.uploadArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }
            
            processFile(file) {
                this.hideError();
                
                // Validate file type
                if (!file.type.includes('pdf')) {
                    this.showError('PDF 파일만 업로드할 수 있습니다.');
                    return;
                }
                
                // Validate file size (50MB limit)
                if (file.size > 50 * 1024 * 1024) {
                    this.showError('파일 크기가 50MB를 초과합니다.');
                    return;
                }
                
                this.currentFile = file;
                this.displayFileInfo(file);
                this.processBtn.disabled = false;
            }
            
            displayFileInfo(file) {
                this.fileName.textContent = file.name;
                this.fileSize.textContent = this.formatFileSize(file.size);
                this.fileInfo.style.display = 'block';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
            }
            
            hideError() {
                this.errorMessage.style.display = 'none';
            }
            
            updateProgress(percent, text) {
                this.progressFill.style.width = percent + '%';
                this.progressText.textContent = text;
            }
            
            async processWatermark() {
                if (!this.currentFile) return;
                
                this.processBtn.disabled = true;
                this.progressSection.style.display = 'block';
                this.downloadSection.style.display = 'none';
                this.hideError();
                
                try {
                    this.updateProgress(10, 'PDF 파일 로딩 중...');
                    
                    // Read PDF file
                    const pdfBytes = await this.readFile(this.currentFile);
                    
                    this.updateProgress(30, 'PDF 문서 파싱 중...');
                    
                    // Load PDF document
                    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                    
                    this.updateProgress(50, '워터마크 추가 중...');
                    
                    // Add watermark to all pages
                    if (this.textWatermark.checked) {
                        await this.addTextWatermark(pdfDoc);
                    } else {
                        await this.addImageWatermark(pdfDoc);
                    }
                    
                    this.updateProgress(80, 'PDF 생성 중...');
                    
                    // Save PDF
                    const pdfBytesWithWatermark = await pdfDoc.save();
                    
                    this.updateProgress(100, '완료!');
                    
                    // Show download section
                    this.showDownloadSection(pdfBytesWithWatermark);
                    
                } catch (error) {
                    console.error('워터마크 처리 중 오류:', error);
                    this.showError('워터마크 처리 중 오류가 발생했습니다: ' + error.message);
                } finally {
                    this.processBtn.disabled = false;
                    this.progressSection.style.display = 'none';
                }
            }
            
            async readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(new Uint8Array(e.target.result));
                    reader.onerror = () => reject(new Error('파일 읽기 실패'));
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async addTextWatermark(pdfDoc) {
                const pages = pdfDoc.getPages();
                const text = this.watermarkText.value || 'WATERMARK';
                const fontSize = parseInt(this.textSize.value);
                const opacity = parseInt(this.opacity.value) / 100;
                
                // Parse color
                const color = this.hexToRgb(this.textColor.value);
                
                // Check if text contains non-ASCII characters (like Korean)
                const hasNonAscii = /[^\x00-\x7F]/.test(text);
                
                let font;
                try {
                    if (hasNonAscii) {
                        // For non-ASCII text, try to use a Unicode-compatible approach
                        // Since we can't easily embed custom fonts, we'll use a different method
                        await this.addTextAsImageWatermark(pdfDoc, text, fontSize, color, opacity);
                        return;
                    } else {
                        // For ASCII text, use standard font
                        font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                    }
                } catch (error) {
                    console.warn('Font embedding failed, using default font:', error);
                    font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                }
                
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const position = this.calculatePosition(width, height, fontSize, text.length);
                    
                    page.drawText(text, {
                        x: position.x,
                        y: position.y,
                        size: fontSize,
                        font: font,
                        color: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255),
                        opacity: opacity,
                        rotate: PDFLib.degrees(-45)
                    });
                }
            }
            
            async addTextAsImageWatermark(pdfDoc, text, fontSize, color, opacity) {
                // Create a canvas to render text as image for non-ASCII characters
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set up canvas size and font
                ctx.font = `${fontSize}px Arial, sans-serif`;
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = fontSize;
                
                // Set canvas size with some padding
                canvas.width = textWidth + 40;
                canvas.height = textHeight + 40;
                
                // Clear canvas and set font again (canvas size change resets context)
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `${fontSize}px Arial, sans-serif`;
                ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                
                // Draw text on canvas
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);
                
                // Convert canvas to PNG data
                const pngDataUrl = canvas.toDataURL('image/png');
                const pngData = pngDataUrl.split(',')[1];
                const pngBytes = Uint8Array.from(atob(pngData), c => c.charCodeAt(0));
                
                // Embed the PNG image
                const image = await pdfDoc.embedPng(pngBytes);
                
                // Add image to all pages
                const pages = pdfDoc.getPages();
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const position = this.calculatePosition(width, height, canvas.width, canvas.height);
                    
                    page.drawImage(image, {
                        x: position.x,
                        y: position.y,
                        width: canvas.width,
                        height: canvas.height,
                        opacity: opacity,
                        rotate: PDFLib.degrees(-45)
                    });
                }
            }
            
            async addImageWatermark(pdfDoc) {
                const imageFile = this.watermarkImage.files[0];
                if (!imageFile) {
                    throw new Error('이미지 파일을 선택해주세요.');
                }
                
                const imageBytes = await this.readFile(imageFile);
                let image;
                
                if (imageFile.type.includes('png')) {
                    image = await pdfDoc.embedPng(imageBytes);
                } else if (imageFile.type.includes('jpeg') || imageFile.type.includes('jpg')) {
                    image = await pdfDoc.embedJpg(imageBytes);
                } else {
                    throw new Error('PNG 또는 JPG 이미지만 지원됩니다.');
                }
                
                const pages = pdfDoc.getPages();
                const imageSize = parseInt(this.imageSize.value);
                const opacity = parseInt(this.opacity.value) / 100;
                
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const position = this.calculatePosition(width, height, imageSize, imageSize);
                    
                    page.drawImage(image, {
                        x: position.x,
                        y: position.y,
                        width: imageSize,
                        height: imageSize,
                        opacity: opacity
                    });
                }
            }
            
            calculatePosition(pageWidth, pageHeight, elementWidth, elementHeight) {
                const positions = {
                    'top-left': { x: 50, y: pageHeight - elementHeight - 50 },
                    'top-center': { x: (pageWidth - elementWidth) / 2, y: pageHeight - elementHeight - 50 },
                    'top-right': { x: pageWidth - elementWidth - 50, y: pageHeight - elementHeight - 50 },
                    'center-left': { x: 50, y: (pageHeight - elementHeight) / 2 },
                    'center': { x: (pageWidth - elementWidth) / 2, y: (pageHeight - elementHeight) / 2 },
                    'center-right': { x: pageWidth - elementWidth - 50, y: (pageHeight - elementHeight) / 2 },
                    'bottom-left': { x: 50, y: 50 },
                    'bottom-center': { x: (pageWidth - elementWidth) / 2, y: 50 },
                    'bottom-right': { x: pageWidth - elementWidth - 50, y: 50 }
                };
                
                return positions[this.selectedPosition] || positions['center'];
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 0, b: 0 };
            }
            
            showDownloadSection(pdfBytes) {
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const fileName = this.currentFile.name.replace(/\.pdf$/i, '_watermarked.pdf');
                
                this.downloadBtn.href = url;
                this.downloadBtn.download = fileName;
                this.downloadSection.style.display = 'block';
                
                // Clean up URL after download
                this.downloadBtn.addEventListener('click', () => {
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                });
            }
        }
        
        // Initialize tool
        document.addEventListener('DOMContentLoaded', () => {
            new PDFWatermarkTool();
        });
        
        // Mobile menu toggle
        function toggleMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('active');
        }
        
        // Close menu when clicking outside
        document.addEventListener('click', function(e) {
            const navBar = document.querySelector('.nav-bar');
            const navLinks = document.getElementById('navLinks');
            if (!navBar.contains(e.target) && navLinks.classList.contains('active')) {
                navLinks.classList.remove('active');
            }
        });
        
        // Close menu when window is resized
        window.addEventListener('resize', function() {
            const navLinks = document.getElementById('navLinks');
            if (window.innerWidth > 768) {
                navLinks.classList.remove('active');
            }
        });
    </script>
</body>
</html>