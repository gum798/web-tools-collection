<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="pdfWatermark.title">PDF 워터마크 추가기 - 무료 온라인 도구</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="PDF 파일에 워터마크를 추가하세요. 텍스트 또는 이미지 워터마크를 지원하며 브라우저에서 안전하게 처리됩니다.">
    <meta name="keywords" content="PDF 워터마크, PDF 텍스트 추가, PDF 이미지 추가, 온라인 PDF 편집">
    <meta name="author" content="Web Tools Collection">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/tools/pdf-tools/pdf-watermark.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/tools/pdf-tools/pdf-watermark.html">
    <meta property="og:title" content="PDF 워터마크 추가기 - 무료 온라인 도구">
    <meta property="og:description" content="PDF 파일에 워터마크를 추가하세요. 브라우저에서 안전하게 처리되어 개인정보 보호가 보장됩니다.">
    <meta property="og:image" content="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/og-image.png">
    <meta property="og:site_name" content="웹 도구 모음">
    <meta property="og:locale" content="ko_KR">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/tools/pdf-tools/pdf-watermark.html">
    <meta property="twitter:title" content="PDF 워터마크 추가기 - 무료 온라인 도구">
    <meta property="twitter:description" content="PDF 파일에 워터마크를 추가하세요. 브라우저에서 안전하게 처리되어 개인정보 보호가 보장됩니다.">
    <meta property="twitter:image" content="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/og-image.png">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>💧</text></svg>">

    <!-- Language Alternatives -->
    <link rel="alternate" hreflang="ko" href="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/tools/pdf-tools/pdf-watermark.html">
    <link rel="alternate" hreflang="en" href="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/en/tools/pdf-tools/pdf-watermark.html">
    <link rel="alternate" hreflang="x-default" href="https://web-tools-collection-git-main-seo-junghwas-projects.vercel.app/en/tools/pdf-tools/pdf-watermark.html">
    
    <!-- i18n System -->
    <script src="../../js/utils/i18n.js"></script>
    
    <!-- PDF-lib Library -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <link rel="stylesheet" href="../../layout/layout.css">
    <link rel="stylesheet" href="../../layout/nav.css">
    <link rel="stylesheet" href="./pdf-tools.css">
</head>
<body>
    <div id="navbar-placeholder"></div>

    <div class="main-layout">
        <div class="container">
            <h1 data-i18n="pdfWatermark.mainTitle">📄 PDF 워터마크 추가기</h1>
            
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📄</div>
                <div class="upload-text" data-i18n="pdfWatermark.uploadText">PDF 파일을 선택하거나 드래그하세요</div>
                <div class="upload-subtext" data-i18n="pdfWatermark.uploadSubtext">지원 형식: .pdf (최대 50MB)</div>
                <input type="file" id="fileInput" accept=".pdf" style="display:none;" />
            </div>

            <div class="file-info" id="fileInfo">
                <div class="file-name" id="fileName"></div>
                <div class="file-size" id="fileSize"></div>
            </div>
            <div class="error-message" id="errorMessage"></div>

            <div class="watermark-options">
                <h3 data-i18n="pdfWatermark.watermarkOptions">워터마크 옵션</h3>
                
                <div class="preview-section">
                    <h4 data-i18n="pdfWatermark.preview">미리보기</h4>
                    <div class="preview-container">
                        <div class="preview-page" id="previewPage">
                            <div class="preview-content">
                                <div class="preview-text">Sample PDF Document</div>
                                <div class="preview-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</div>
                                <div class="preview-text">Sed do eiusmod tempor incididunt ut labore et dolore magna.</div>
                                <div class="preview-text">Ut enim ad minim veniam, quis nostrud exercitation.</div>
                                <div class="preview-watermark" id="previewWatermark">
                                    <span id="previewText">WATERMARK</span>
                                    <img id="previewImage" style="display: none;" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="watermark-type">
                    <div class="type-option">
                        <input type="radio" name="watermarkType" id="textWatermark" value="text" checked>
                        <label for="textWatermark" data-i18n="pdfWatermark.textWatermark">텍스트 워터마크</label>
                    </div>
                    <div class="type-option">
                        <input type="radio" name="watermarkType" id="imageWatermark" value="image">
                        <label for="imageWatermark" data-i18n="pdfWatermark.imageWatermark">이미지 워터마크</label>
                    </div>
                </div>
                
                <div class="text-watermark-options active" id="textOptions">
                    <div class="option-group">
                        <label for="watermarkText" data-i18n="pdfWatermark.watermarkText">워터마크 텍스트:</label>
                        <input type="text" id="watermarkText" placeholder="워���마크 텍스트를 입력하세요" data-i18n-placeholder="pdfWatermark.textPlaceholder">
                        <small style="color: #666; font-size: 0.9em; margin-top: 5px; display: block;" data-i18n="pdfWatermark.textNote">
                            ℹ️ 한글/특수문자는 이미지로 변환되어 처리됩니다
                        </small>
                    </div>
                    
                    <div class="option-group">
                        <label for="textSize" data-i18n="pdfWatermark.textSize">텍스트 크기: <span class="range-value" id="textSizeValue">36px</span></label>
                        <input type="range" id="textSize" min="12" max="72" value="36" />
                    </div>
                    
                    <div class="option-group">
                        <label for="textColor" data-i18n="pdfWatermark.textColor">텍스트 색상:</label>
                        <div class="color-picker-container">
                            <div class="color-preview" id="colorPreview" style="background-color: #e74c3c;"></div>
                            <input type="color" id="textColor" value="#e74c3c" />
                            <div class="color-presets">
                                <div class="color-preset" data-color="#000000" style="background-color: #000000;" title="검정"></div>
                                <div class="color-preset" data-color="#e74c3c" style="background-color: #e74c3c;" title="빨강"></div>
                                <div class="color-preset" data-color="#3498db" style="background-color: #3498db;" title="파랑"></div>
                                <div class="color-preset" data-color="#2ecc71" style="background-color: #2ecc71;" title="초록"></div>
                                <div class="color-preset" data-color="#f39c12" style="background-color: #f39c12;" title="주황"></div>
                                <div class="color-preset" data-color="#9b59b6" style="background-color: #9b59b6;" title="보라"></div>
                                <div class="color-preset" data-color="#95a5a6" style="background-color: #95a5a6;" title="회색"></div>
                                <div class="color-preset" data-color="#34495e" style="background-color: #34495e;" title="네이비"></div>
                            </div>
                            <div class="color-hex-input">
                                <span>#</span>
                                <input type="text" id="hexColorInput" value="e74c3c" maxlength="6" placeholder="ffffff">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="image-watermark-options" id="imageOptions">
                    <div class="option-group">
                        <label for="watermarkImage" data-i18n="pdfWatermark.watermarkImage">워터마크 이미지:</label>
                        <input type="file" id="watermarkImage" accept="image/*" />
                    </div>
                    
                    <div class="option-group">
                        <label for="imageSize" data-i18n="pdfWatermark.imageSize">이미지 크기: <span class="range-value" id="imageSizeValue">100px</span></label>
                        <input type="range" id="imageSize" min="50" max="300" value="100" />
                    </div>
                </div>
                
                <div class="option-group">
                    <label for="opacity" data-i18n="pdfWatermark.opacity">투명도: <span class="range-value" id="opacityValue">50%</span></label>
                    <input type="range" id="opacity" min="10" max="100" value="50" />
                </div>
                
                <div class="option-group">
                    <label data-i18n="pdfWatermark.position">위치:</label>
                    <div class="position-grid">
                        <button class="position-btn" data-position="top-left" data-i18n="pdfWatermark.topLeft">왼쪽 상단</button>
                        <button class="position-btn" data-position="top-center" data-i18n="pdfWatermark.topCenter">중앙 상단</button>
                        <button class="position-btn" data-position="top-right" data-i18n="pdfWatermark.topRight">오른쪽 상단</button>
                        <button class="position-btn" data-position="center-left" data-i18n="pdfWatermark.centerLeft">왼쪽 중앙</button>
                        <button class="position-btn active" data-position="center" data-i18n="pdfWatermark.center">중앙</button>
                        <button class="position-btn" data-position="center-right" data-i18n="pdfWatermark.centerRight">오른쪽 중앙</button>
                        <button class="position-btn" data-position="bottom-left" data-i18n="pdfWatermark.bottomLeft">왼쪽 하단</button>
                        <button class="position-btn" data-position="bottom-center" data-i18n="pdfWatermark.bottomCenter">중앙 하단</button>
                        <button class="position-btn" data-position="bottom-right" data-i18n="pdfWatermark.bottomRight">오른쪽 하단</button>
                    </div>
                </div>
            </div>
            
            <button class="convert-btn" id="processBtn" disabled data-i18n="pdfWatermark.addWatermark">워터마크 추가하기</button>
            
            <div class="progress-section" id="progressSection">
                <div class="progress-text" id="progressText" data-i18n="pdfWatermark.processing">처리 중...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            <div class="download-section" id="downloadSection">
                <h3 data-i18n="pdfWatermark.complete">✅ 완료!</h3>
                <p data-i18n="pdfWatermark.completeDesc">PDF 파일에 워터마크가 성공적으로 추가되었습니다.</p>
                <a href="#" class="download-btn" id="downloadBtn" data-i18n="pdfWatermark.downloadBtn">📥 PDF 다운로드</a>
            </div>

            <div class="features-section">
                <div class="feature-card">
                    <div class="feature-icon">🔒</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.privacy.title">개인정보 보호</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.privacy.description">모든 처리는 브라우저에�� 직접 수행되어 파일이 서버로 전송되지 않습니다.</div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">⚡</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.fast.title">빠른 처리</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.fast.description">최적화된 알고리즘으로 빠르고 정확한 워터마크 추가를 제공합니다.</div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">🎨</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.customizable.title">다양한 옵션</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.customizable.description">텍스트와 이미지 워터마크, 위치, 크기, 투명도 등을 자유롭게 설정할 수 있습니다.</div>
                </div>
                
                <div class="feature-card">
                    <div class="feature-icon">📱</div>
                    <div class="feature-title" data-i18n="pdfWatermark.features.responsive.title">모든 기기 지원</div>
                    <div class="feature-description" data-i18n="pdfWatermark.features.responsive.description">PC, 태블릿, 모바일 등 모든 기기에서 사용할 수 있습니다.</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PDFWatermarkTool {
            constructor() {
                this.currentFile = null;
                this.selectedPosition = 'center';
                this.initializeElements();
                this.bindEvents();
                this.updateRangeValues();
                this.updateColorPreview(); // 초기 색상 미리보기 설정
                this.updatePreview(); // 초기 미리보기 설정
            }
            
            initializeElements() {
                // 기본 요소들
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.fileInfo = document.getElementById('fileInfo');
                this.fileName = document.getElementById('fileName');
                this.fileSize = document.getElementById('fileSize');
                this.processBtn = document.getElementById('processBtn');
                this.progressSection = document.getElementById('progressSection');
                this.progressText = document.getElementById('progressText');
                this.progressFill = document.getElementById('progressFill');
                this.downloadSection = document.getElementById('downloadSection');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.errorMessage = document.getElementById('errorMessage');
                
                // Watermark option elements
                this.textWatermark = document.getElementById('textWatermark');
                this.imageWatermark = document.getElementById('imageWatermark');
                this.textOptions = document.getElementById('textOptions');
                this.imageOptions = document.getElementById('imageOptions');
                this.watermarkText = document.getElementById('watermarkText');
                this.textSize = document.getElementById('textSize');
                this.textColor = document.getElementById('textColor');
                this.watermarkImage = document.getElementById('watermarkImage');
                this.imageSize = document.getElementById('imageSize');
                this.opacity = document.getElementById('opacity');
                
                // Position buttons
                this.positionButtons = document.querySelectorAll('.position-btn');
                
                // Preview elements
                this.previewWatermark = document.getElementById('previewWatermark');
                this.previewText = document.getElementById('previewText');
                this.previewImage = document.getElementById('previewImage');
                
                // Color picker elements
                this.colorPreview = document.getElementById('colorPreview');
                this.hexColorInput = document.getElementById('hexColorInput');
                this.colorPresets = document.querySelectorAll('.color-preset');
            }
            
            bindEvents() {
                // File input events
                this.uploadArea.addEventListener('click', () => this.fileInput.click());
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e));
                
                // Drag and drop events
                this.uploadArea.addEventListener('dragover', (e) => this.handleDragOver(e));
                this.uploadArea.addEventListener('dragleave', (e) => this.handleDragLeave(e));
                this.uploadArea.addEventListener('drop', (e) => this.handleDrop(e));
                
                // Watermark type change
                this.textWatermark.addEventListener('change', () => {
                    this.toggleWatermarkType();
                    this.updatePreview();
                });
                this.imageWatermark.addEventListener('change', () => {
                    this.toggleWatermarkType();
                    this.updatePreview();
                });
                
                // Text input changes
                this.watermarkText.addEventListener('input', () => this.updatePreview());
                this.textColor.addEventListener('input', () => {
                    this.updateColorPreview();
                    this.updatePreview();
                });
                this.watermarkImage.addEventListener('change', () => this.updatePreview());
                
                // Color picker events
                this.colorPreview.addEventListener('click', () => this.textColor.click());
                this.hexColorInput.addEventListener('input', (e) => this.handleHexInput(e));
                this.colorPresets.forEach(preset => {
                    preset.addEventListener('click', (e) => this.selectColorPreset(e));
                });
                
                if (this.textSize) {
                    this.textSize.addEventListener('input', (e) => {
                        this.updateRangeValues();
                        this.updatePreview();
                    });
                }
                if (this.imageSize) {
                    this.imageSize.addEventListener('input', (e) => {
                        this.updateRangeValues();
                        this.updatePreview();
                    });
                }
                if (this.opacity) {
                    this.opacity.addEventListener('input', (e) => {
                        this.updateRangeValues();
                        this.updatePreview();
                    });
                }
                
                // Position buttons
                this.positionButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.selectPosition(btn);
                        this.updatePreview();
                    });
                });
                
                // Process button
                this.processBtn.addEventListener('click', () => this.processWatermark());
            }
            
            updateRangeValues() {
                const textSizeValue = document.getElementById('textSizeValue');
                const imageSizeValue = document.getElementById('imageSizeValue');
                const opacityValue = document.getElementById('opacityValue');
                
                if (textSizeValue && this.textSize) {
                    textSizeValue.textContent = this.textSize.value + 'px';
                }
                if (imageSizeValue && this.imageSize) {
                    imageSizeValue.textContent = this.imageSize.value + 'px';
                }
                if (opacityValue && this.opacity) {
                    opacityValue.textContent = this.opacity.value + '%';
                }
            }
            
            updatePreview() {
                const isTextWatermark = this.textWatermark.checked;
                
                if (isTextWatermark) {
                    this.updateTextPreview();
                } else {
                    this.updateImagePreview();
                }
                
                this.updateWatermarkPosition();
            }
            
            updateTextPreview() {
                const text = this.watermarkText.value || 'WATERMARK';
                const fontSize = parseInt(this.textSize.value);
                const color = this.textColor.value;
                const opacity = (110 - parseInt(this.opacity.value)) / 100;
                
                const previewFontSize = Math.max(fontSize * 0.5, 12);
                
                const newSpan = document.createElement('span');
                newSpan.id = 'previewText';
                newSpan.textContent = text;
                
                newSpan.style.fontFamily = 'Arial, sans-serif';
                newSpan.style.fontSize = `${previewFontSize}px`;
                newSpan.style.color = color;
                newSpan.style.opacity = opacity;
                newSpan.style.whiteSpace = 'nowrap';
                newSpan.style.textShadow = '1px 1px 3px rgba(0,0,0,0.3)';
                newSpan.style.fontWeight = 'bold';
                newSpan.style.display = 'block';
                newSpan.style.position = 'absolute';
                newSpan.style.top = '0';
                newSpan.style.left = '0';
                newSpan.style.width = '100%';
                newSpan.style.height = '100%';
                newSpan.style.display = 'flex';
                newSpan.style.alignItems = 'center';
                newSpan.style.justifyContent = 'center';
                
                this.previewText.parentNode.replaceChild(newSpan, this.previewText);
                this.previewText = newSpan;
                
                this.previewImage.style.display = 'none';
            }
            
            updateImagePreview() {
                const imageFile = this.watermarkImage.files[0];
                const imageSize = parseInt(this.imageSize.value);
                const opacity = (110 - parseInt(this.opacity.value)) / 100;
                
                if (imageFile) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const previewSize = Math.max(imageSize * 0.5, 30);
                        
                        const newImg = document.createElement('img');
                        newImg.id = 'previewImage';
                        newImg.src = e.target.result;
                        
                        newImg.setAttribute('style', `
                            width: ${previewSize}px;
                            height: ${previewSize}px;
                            opacity: ${opacity};
                            display: block;
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                        `);
                        
                        this.previewImage.parentNode.replaceChild(newImg, this.previewImage);
                        this.previewImage = newImg;
                        
                        this.previewText.style.display = 'none';
                    };
                    reader.readAsDataURL(imageFile);
                } else {
                    this.previewImage.style.display = 'none';
                    this.previewText.style.display = 'none';
                }
            }
            
            updateWatermarkPosition() {
                const position = this.selectedPosition;
                const container = this.previewWatermark;
                
                container.style.top = '50%';
                container.style.left = '50%';
                container.style.transform = 'translate(-50%, -50%) rotate(-45deg)';
                
                switch (position) {
                    case 'top-left':
                        container.style.top = '25%';
                        container.style.left = '25%';
                        break;
                    case 'top-center':
                        container.style.top = '25%';
                        container.style.left = '50%';
                        break;
                    case 'top-right':
                        container.style.top = '25%';
                        container.style.left = '75%';
                        break;
                    case 'center-left':
                        container.style.top = '50%';
                        container.style.left = '25%';
                        break;
                    case 'center':
                        container.style.top = '50%';
                        container.style.left = '50%';
                        break;
                    case 'center-right':
                        container.style.top = '50%';
                        container.style.left = '75%';
                        break;
                    case 'bottom-left':
                        container.style.top = '75%';
                        container.style.left = '25%';
                        break;
                    case 'bottom-center':
                        container.style.top = '75%';
                        container.style.left = '50%';
                        break;
                    case 'bottom-right':
                        container.style.top = '75%';
                        container.style.left = '75%';
                        break;
                }
            }
            
            toggleWatermarkType() {
                if (this.textWatermark.checked) {
                    this.textOptions.classList.add('active');
                    this.imageOptions.classList.remove('active');
                } else {
                    this.textOptions.classList.remove('active');
                    this.imageOptions.classList.add('active');
                }
            }
            
            selectPosition(btn) {
                this.positionButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.selectedPosition = btn.dataset.position;
            }
            
            updateColorPreview() {
                const color = this.textColor.value;
                this.colorPreview.style.backgroundColor = color;
                this.hexColorInput.value = color.substring(1);
                this.updateColorPresetSelection(color);
            }
            
            updateColorPresetSelection(color) {
                this.colorPresets.forEach(preset => {
                    preset.classList.remove('active');
                    if (preset.dataset.color.toLowerCase() === color.toLowerCase()) {
                        preset.classList.add('active');
                    }
                });
            }
            
            selectColorPreset(e) {
                const color = e.target.dataset.color;
                this.textColor.value = color;
                this.updateColorPreview();
                this.updatePreview();
            }
            
            handleHexInput(e) {
                let hex = e.target.value.replace(/[^0-9a-fA-F]/g, '');
                if (hex.length > 6) {
                    hex = hex.substring(0, 6);
                }
                e.target.value = hex;
                
                if (hex.length === 6) {
                    const color = '#' + hex;
                    this.textColor.value = color;
                    this.colorPreview.style.backgroundColor = color;
                    this.updateColorPresetSelection(color);
                    this.updatePreview();
                }
            }
            
            handleDragOver(e) {
                e.preventDefault();
                this.uploadArea.classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                this.uploadArea.classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                this.uploadArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.processFile(files[0]);
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }
            
            processFile(file) {
                this.hideError();
                
                if (!file.type.includes('pdf')) {
                    this.showError('PDF 파일만 업로드할 수 있습니다.');
                    return;
                }
                
                if (file.size > 50 * 1024 * 1024) {
                    this.showError('파일 크기가 50MB를 초과합니다.');
                    return;
                }
                
                this.currentFile = file;
                this.displayFileInfo(file);
                this.processBtn.disabled = false;
            }
            
            displayFileInfo(file) {
                this.fileName.textContent = file.name;
                this.fileSize.textContent = this.formatFileSize(file.size);
                this.fileInfo.style.display = 'block';
            }
            
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
            
            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
            }
            
            hideError() {
                this.errorMessage.style.display = 'none';
            }
            
            updateProgress(percent, text) {
                this.progressFill.style.width = percent + '%';
                this.progressText.textContent = text;
            }
            
            async processWatermark() {
                if (!this.currentFile) return;
                
                this.processBtn.disabled = true;
                this.progressSection.style.display = 'block';
                this.downloadSection.style.display = 'none';
                this.hideError();
                
                try {
                    this.updateProgress(10, 'PDF 파일 로딩 중...');
                    
                    const pdfBytes = await this.readFile(this.currentFile);
                    
                    this.updateProgress(30, 'PDF 문서 파싱 중...');
                    
                    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
                    
                    this.updateProgress(50, '워터��크 추가 중...');
                    
                    if (this.textWatermark.checked) {
                        await this.addTextWatermark(pdfDoc);
                    } else {
                        await this.addImageWatermark(pdfDoc);
                    }
                    
                    this.updateProgress(80, 'PDF 생성 중...');
                    
                    const pdfBytesWithWatermark = await pdfDoc.save();
                    
                    this.updateProgress(100, '완료!');
                    
                    this.showDownloadSection(pdfBytesWithWatermark);
                    
                } catch (error) {
                    console.error('워터마크 처리 중 오류:', error);
                    this.showError('워터마크 처리 중 오류가 발생했습니다: ' + error.message);
                } finally {
                    this.processBtn.disabled = false;
                    this.progressSection.style.display = 'none';
                }
            }
            
            async readFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(new Uint8Array(e.target.result));
                    reader.onerror = () => reject(new Error('파일 읽기 실패'));
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async addTextWatermark(pdfDoc) {
                const pages = pdfDoc.getPages();
                const text = this.watermarkText.value || 'WATERMARK';
                const fontSize = parseInt(this.textSize.value);
                const opacity = (110 - parseInt(this.opacity.value)) / 100;
                
                const color = this.hexToRgb(this.textColor.value);
                
                const hasNonAscii = /[^\x00-\x7F]/.test(text);
                
                let font;
                try {
                    if (hasNonAscii) {
                        await this.addTextAsImageWatermark(pdfDoc, text, fontSize, color, opacity);
                        return;
                    } else {
                        font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                    }
                } catch (error) {
                    console.warn('Font embedding failed, using default font:', error);
                    font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
                }
                
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const position = this.calculatePosition(width, height, fontSize, text.length);
                    
                    page.drawText(text, {
                        x: position.x,
                        y: position.y,
                        size: fontSize * 5,
                        font: font,
                        color: PDFLib.rgb(color.r / 255, color.g / 255, color.b / 255),
                        opacity: opacity,
                        rotate: PDFLib.degrees(45)
                    });
                }
            }
            
            async addTextAsImageWatermark(pdfDoc, text, fontSize, color, opacity) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                ctx.font = `${fontSize * 5}px Arial, sans-serif`;
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = fontSize;
                
                canvas.width = textWidth + 40;
                canvas.height = textHeight + 40;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = `${fontSize * 5}px Arial, sans-serif`;
                ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const pngDataUrl = canvas.toDataURL('image/png');
                const pngData = pngDataUrl.split(',')[1];
                const pngBytes = Uint8Array.from(atob(pngData), c => c.charCodeAt(0));
                
                const image = await pdfDoc.embedPng(pngBytes);
                
                const pages = pdfDoc.getPages();
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const position = this.calculatePosition(width, height, canvas.width, canvas.height);
                    
                    page.drawImage(image, {
                        x: position.x,
                        y: position.y,
                        width: canvas.width,
                        height: canvas.height,
                        opacity: opacity,
                        rotate: PDFLib.degrees(45)
                    });
                }
            }
            
            async addImageWatermark(pdfDoc) {
                const imageFile = this.watermarkImage.files[0];
                if (!imageFile) {
                    throw new Error('이미지 파일을 선택��주세요.');
                }
                
                const imageBytes = await this.readFile(imageFile);
                let image;
                
                if (imageFile.type.includes('png')) {
                    image = await pdfDoc.embedPng(imageBytes);
                } else if (imageFile.type.includes('jpeg') || imageFile.type.includes('jpg')) {
                    image = await pdfDoc.embedJpg(imageBytes);
                } else {
                    throw new Error('PNG 또는 JPG 이미지만 지원됩니다.');
                }
                
                const pages = pdfDoc.getPages();
                const imageSize = parseInt(this.imageSize.value);
                const opacity = (110 - parseInt(this.opacity.value)) / 100;
                
                for (const page of pages) {
                    const { width, height } = page.getSize();
                    const position = this.calculatePosition(width, height, imageSize, imageSize);
                    
                    page.drawImage(image, {
                        x: position.x,
                        y: position.y,
                        width: imageSize,
                        height: imageSize,
                        opacity: opacity
                    });
                }
            }
            
            calculatePosition(pageWidth, pageHeight, elementWidth, elementHeight) {
                const positions = {
                    'top-left': { x: 50, y: pageHeight - elementHeight - 50 },
                    'top-center': { x: (pageWidth - elementWidth) / 2, y: pageHeight - elementHeight - 50 },
                    'top-right': { x: pageWidth - elementWidth - 50, y: pageHeight - elementHeight - 50 },
                    'center-left': { x: 50, y: (pageHeight - elementHeight) / 2 },
                    'center': { x: (pageWidth - elementWidth) / 2, y: (pageHeight - elementHeight) / 2 },
                    'center-right': { x: pageWidth - elementWidth - 50, y: (pageHeight - elementHeight) / 2 },
                    'bottom-left': { x: 50, y: 50 },
                    'bottom-center': { x: (pageWidth - elementWidth) / 2, y: 50 },
                    'bottom-right': { x: pageWidth - elementWidth - 50, y: 50 }
                };
                
                return positions[this.selectedPosition] || positions['center'];
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 0, b: 0 };
            }
            
            showDownloadSection(pdfBytes) {
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const fileName = this.currentFile.name.replace(/\.pdf$/i, '_watermarked.pdf');
                
                this.downloadBtn.href = url;
                this.downloadBtn.download = fileName;
                this.downloadSection.style.display = 'block';
                
                this.downloadBtn.addEventListener('click', () => {
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            new PDFWatermarkTool();
        });
    </script>
    <script src="../../js/utils/nav-loader.js"></script>
</body>
</html>
